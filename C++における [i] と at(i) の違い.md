

## In a nutshell



## はじめに




C++の標準ライブラリ（STL）において、`std::vector` や `std::string` などのコンテナから要素を取得する方法として、`[i]` と `at(i)` の2つがあります。一見似ていますが、大きな違いがあります。

このドキュメントでは、初学者向けにこの2つの違いをわかりやすく解説し、使い分けの指針や注意点も紹介します。



## 基本的な仕様の違い

| 機能        | `[i]`                   | `at(i)`                          |
|-------------|--------------------------|----------------------------------|
| 範囲チェック | なし（未定義動作）       | あり（範囲外で例外を投げる）     |
| 戻り値型     | 要素の参照（読み書き可能）| 要素の参照（読み書き可能）       |
| 例外発生     | なし                     | 範囲外で `std::out_of_range`     |
| パフォーマンス | 高い                    | やや低い（範囲チェックの分だけ） |



## 具体的な違いとコード例

### `[i]` の使用例

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {10, 20, 30};
    std::cout << vec[1] << std::endl; // 出力: 20
    std::cout << vec[3] << std::endl; // 範囲外 → 未定義動作
}
```

このコードは一見問題なく動きますが、`vec[3]` は存在しないインデックスのため、プログラムがクラッシュする可能性があります。

### `at(i)` の使用例

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {10, 20, 30};
    try {
        std::cout << vec.at(1) << std::endl; // 出力: 20
        std::cout << vec.at(3) << std::endl; // 例外が発生
    } catch (std::out_of_range& e) {
        std::cerr << "範囲外アクセスです: " << e.what() << std::endl;
    }
}
```

`at(i)` を使うと、安全に範囲外アクセスを防ぐことができ、デバッグ時に非常に有用です。





## 使い分け

### `at(i)` を使うべき場合
- 安全性を重視するコード
- デバッグ中や教育目的のコード
- ユーザー入力など、不確定なインデックスでアクセスする場合

### `[i]` を使うべき場合
- パフォーマンスが重要な場合
- インデックスの正当性を事前に保証できる場合
- ループ内で大量アクセスがある処理



## 注意すること・例外的なこと

- `std::vector` 以外のコンテナでも `at(i)` が使えるものがあります（例：`std::string`、`std::array` など）。
- `std::map` や `std::unordered_map` の `operator[]` はキーが存在しない場合に自動的に要素を追加するため、挙動が異なります。
- `at(i)` は存在しないキーに対して例外を投げる点でより安全です。

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<std::string, int> mp;

    mp["key1"] = 10;
    std::cout << mp["key2"] << std::endl; // 0が挿入される

    try {
        std::cout << mp.at("key3") << std::endl; // 例外が発生
    } catch (std::out_of_range& e) {
        std::cout << "存在しないキーです: " << e.what() << std::endl;
    }
}
```



## 補足

- `at()` による例外処理は、C++の例外処理メカニズム（try-catch）とセットで使うのが基本です。
- `[i]` は範囲外アクセス時に何も言わずクラッシュやバグを引き起こす可能性があるため、本番環境のコードでは慎重に使うべきです。
- C++20以降では、`std::span` という新しいビュー型が導入されており、安全かつ柔軟に配列・ベクターを扱えます。`span` にも `at()` 相当の安全なアクセス方法があります。



## まとめ

| 観点          | `[i]`               | `at(i)`                      |
|---------------|----------------------|-------------------------------|
| 安全性         | 低い（未定義動作）    | 高い（例外処理あり）           |
| パフォーマンス | 高い                 | 低い（安全性の分だけ遅い）     |
| デバッグ適性   | 低い                 | 高い                          |
| 推奨場面       | 高速処理・内部処理    | ユーザー入力・学習・デバッグ時 |






## Summary




## References


