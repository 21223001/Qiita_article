
## In a nutshell

Pythonにおける `if __name__ == '__main__':` は，スクリプトが直接実行されたときにだけ処理を行う条件分岐である．C++の `main()` に似た役割を担うが，柔軟な設計が可能であり，モジュールとしての再利用も安全に行える．設計上は `main()` 関数に処理をまとめる構造が推奨される．



## はじめに

Pythonにおける `if __name__ == '__main__':` という記述は，Pythonスクリプトを書く上で頻繁に登場する．これはスクリプトの実行の入り口(エントリーポイント)を制御するための記述であるが，普段はC++を利用しているため，`int main()` の感覚で使用をしていた．改めて適切に理解すべきであると考えたので，以下に記事としてまとめる．


## 予想される読み手

 - Pythonに関して初学者である
 - `if __name__ == '__main__':` について，適切な理解が必要と感じている


## 機能

この構文の主な機能は，「そのスクリプトが直接実行されたときだけ，特定の処理を実行する」という条件を記述することである．逆に，モジュールとして他のスクリプトからインポートされたときには実行されないという制御を実現する．Pythonスクリプトが実行されると，Pythonは自動的に `__name__` という特殊変数を定義する．この仕組みにより，実行時の処理とインポート時の処理を分離できる．

- スクリプトが**直接実行**されたとき:`__name__ == '__main__'`
- スクリプトが**インポート**されたとき:`__name__ == モジュール名`



## 用途
この構文の典型的な用途は以下の通りである．

- テストコードやデモの実行
- メイン処理の定義
- 再利用可能なモジュールの作成

```python
def greet():
    print("Hello!")

if __name__ == '__main__':  # ここがエントリーポイント
    greet()
```

このコードを `example.py` として実行した場合には，`python example.py` では実行されて `Hello!` が表示される．`import example` では関数は定義されるが表示はされない．


## `__main__` ではない場合

Pythonスクリプトが**インポート**されると，`__name__` には `'__main__'` ではなく，**ファイル名(モジュール名)**が代入される．この挙動により，**直接実行されたとき**と**モジュールとして使われたとき**で処理を切り分けることができる．
例:`my_module.py` を `import my_module` で読み込むと，`my_module.py` 内の `__name__ == 'my_module'` となる．


## なぜ `if __name__ == '__main__':` が必要か？

- `__name__` はPythonが定義する特殊変数である．
- `'__main__'` は，スクリプトが直接実行された場合に与えられる特別な文字列である．
- `__name__` のようにアンダースコア2つに囲まれた名前は**マジック変数(ダンダー変数)**と呼ばれる．


## エントリーポイントという認識

これはエントリーポイントという認識で問題ない．Pythonでは `if __name__ == '__main__':` を**プログラムのエントリーポイント**として使用することが一般的である．この構造により，**スクリプトとしての実行**と**モジュールとしての再利用**を両立できるようになる．


## C++の `int main()` との相違点
C++では `main` 関数がなければコンパイルエラーになるが，Pythonはより柔軟な構造を許容する．

| 観点 | Python (`__name__ == '__main__'`) | C++ (`int main()`) |
|------|----------------------------------|---------------------|
| 必須性 | 任意(ただし推奨) | 必須 |
| 用途 | 実行の分岐制御，再利用性向上 | 実行の開始点 |
| 実行対象 | 条件ブロック内 | main関数全体 |
| モジュール性 | モジュールとしての使用可能 | 単一の実行形式が基本 |



## 注意点とベストプラクティス
### 複数記述した場合
`if __name__ == '__main__':` は複数記述してもPythonとしては正しく動作し，それぞれが実行される．但し，**処理が分散して保守性が下がるため，通常は1箇所にまとめるべき**である．


```python
if __name__ == '__main__':
    print("Block 1")

if __name__ == '__main__':
    print("Block 2")
```

出力:

```
Block 1
Block 2
```


### 呼び出し先ファイルに記述があった場合

以下のような構成:

```python
# module_a.py
def func():
    print("Function called")

if __name__ == '__main__':
    print("This is main in module_a")

# main.py
import module_a
module_a.func()
```

`main.py` を実行すると，`module_a` の `__main__` ブロックは実行されない．出力は次の通り:

```
Function called
```

-> モジュールとしての再利用時にも安全に扱える．


## エラーハンドリングと設計上の工夫
### 例外処理との組み合わせ

```python
def main():
    raise ValueError("テスト用の例外")

if __name__ == '__main__':
    try:
        main()
    except Exception as e:
        print(f"エラーが発生しました: {e}")
```

-> 予期せぬ例外でプログラムが中断するのを防ぐ．


### main関数として切り出す設計

```python
def main():
    print("メイン処理")

if __name__ == '__main__':
    main()
```

このようにすることで:

- テストコードで `main()` を直接呼べる
- 可読性が高まる
- 再利用しやすい


## コマンドライン引数との併用

```python
import sys

def main():
    if len(sys.argv) < 2:
        print("使い方: python script.py 引数")
    else:
        print(f"引数: {sys.argv[1]}")

if __name__ == '__main__':
    main()
```

-> コマンドライン引数の解析処理も簡単に組み込める．


## まとめの表

| 項目 | 内容 |
|------|------|
| 複数の `if __name__ == '__main__':` | すべて実行されるが，推奨されない |
| モジュール内の記述 | インポートされた場合には無視される |
| エラーハンドリング | try-except を使用して安全に実行すべき |
| 設計の推奨 | `main()` 関数にまとめてから実行する構造が望ましい |



## Summary

- `__name__ == '__main__'` は，直接実行されたときだけ処理を行う条件分岐である  
- スクリプトをモジュールとしてインポートした場合にはブロックは無視される  
- 複数記述は可能だが，保守性の観点から1つにまとめるのが望ましい  
- `main()` 関数への処理の集約が再利用性・可読性を高める  
- 例外処理は `try-except` で安全な設計が可能  
- C++の `main()` と似て非なる構造であり，Python特有の柔軟性がある


## References

[Python公式ドキュメント:  __main__ — Top-level code environment](https://docs.python.org/3/library/__main__.html)

[ Pythonチュートリアル: 6. Modules¶l](https://docs.python.org/3/tutorial/modules.html)

